defmodule Genus do
  defmacro __using__(_) do
    quote do
      require Genus
      import Genus, only: [genus: 1]
    end
  end

  defp nullable(true), do: "?"
  defp nullable(_), do: ""

  defp as_ts(is_nullable, {[name, :string], _default}),
    do: "#{name}#{nullable(is_nullable)}: string"

  defp as_ts(is_nullable, {[name, :integer], _default}),
    do: "#{name}#{nullable(is_nullable)}: number"

  defp as_ts(is_nullable, {[name, :float], _default}),
    do: "#{name}#{nullable(is_nullable)}: number"

  defp as_ts(is_nullable, {[name, :bool], _default}),
    do: "#{name}#{nullable(is_nullable)}: boolean"

  # external types have to be nullable
  defp as_ts(_is_nullable, {[name, :external, type_name], nil}), do: "#{name}?: #{type_name}"

  defp as_ts(is_nullable, {[name, :union, type_name, _is_string, values], default}) do
    if default == nil or default in values do
      :ok
    else
      raise "Default value `#{default}`, for field `#{name}`, not found in union values"
    end

    "#{name}#{nullable(is_nullable)}: #{type_name}"
  end

  defp as_ts(is_nullable, {[name, :union, type_name, values], default}),
    do: as_ts(is_nullable, {[name, :union, type_name, false, values], default})

  defp as_ts(is_nullable, {[name, :list, type_name], default}),
    do: "#{as_ts(is_nullable, {[name, type_name], default})}[]"

  defp as_ts(is_nullable, {[name, v], _default}), do: "#{name}#{nullable(is_nullable)}: #{v}"
  defp as_ts(is_nullable, {[name], _default}), do: "#{name}#{nullable(is_nullable)}: any"

  defp as_union({[name, :union, type_name, values], default}),
    do: as_union({[name, :union, type_name, false, values], default})

  defp as_union({[_, :union, type_name, is_string, values], _default}) do
    values =
      if is_string do
        Enum.map(values, &"\"#{&1}\"")
      else
        values
      end
      |> Enum.join(" | ")

    "export type #{type_name} = #{values}"
  end

  defp as_union(_), do: ""

  defp indent(string, level) do
    indent_spacer = Application.get_env(:genus, :indent, "  ")

    case level do
      0 ->
        string

      _ ->
        (1..level
         |> Enum.map(fn _ -> indent_spacer end)
         |> Enum.reduce(&(&1 <> &2))) <>
          string
    end
  end

  defp format(strings, opts \\ []),
    do:
      Enum.map(strings, &indent(&1, Access.get(opts, :level, 0)))
      |> Enum.join(Access.get(opts, :seperator, "\n"))

  defp get_defaults(field) do
    case field do
      {f, v} -> {f, v}
      f when is_list(f) -> {f, nil}
      f -> {f, nil}
    end
  end

  defp js_literal({name, value}) do
    value =
      case value do
        :required -> Atom.to_string(name)
        _ -> "#{name} || " <> Genus.JSLiteral.literal(value)
      end

    "#{name}: " <> value <> ","
  end

  defp format_struct({[name | _rest], default}) when is_atom(name), do: {name, default}

  defp required?(field) do
    case field do
      {_, :required} -> true
      _ -> false
    end
  end

  defp as_param(field) do
    case field do
      {[name | _], _} -> name
    end
  end

  defp import_or_val(name, val) do
    if val == nil do
      {name, name}
    else
      {name, val}
    end
  end

  defp build_import_tuples(generated_import, overrides) do
    case generated_import do
      {[_, :external, name], _default} when is_binary(name) ->
        import_or_val(name, Access.get(overrides, String.to_atom(name)))

      {[_, :list, name], _default} when is_binary(name) ->
        import_or_val(name, Access.get(overrides, String.to_atom(name)))

      {name, file} when is_atom(name) and is_binary(file) ->
        {name, file}

      _ ->
        nil
    end
  end

  defp build_import({name, file}), do: "import type { #{name} } from \"./#{file}\""

  defp build(name, fields, required_fields, other_imports, caller) do
    header = """
    // Do Not Modify! This file was generated by Genus from an Elixir struct @ #{caller.module}
    // https://github.com/bwireman/genus
    """

    snake_case_name = Macro.underscore(name)

    imports =
      Enum.map(fields, &build_import_tuples(&1, other_imports))
      |> Enum.filter(&(&1 != nil))
      |> Enum.concat(other_imports)
      |> Enum.map(&build_import/1)
      |> Enum.dedup()
      |> format()

    unions = Enum.map(fields, &as_union/1) |> format()

    type_def = Enum.map(fields, &as_ts(elem(&1, 1) == nil, &1)) |> format(level: 1)
    all_nullable = Enum.map(fields, &as_ts(!required?(&1), &1)) |> format(level: 1)

    interface = "export interface #{name} {\n" <> type_def <> "\n}"

    apply = "export const apply_#{snake_case_name} = (v: any): #{name} => v"

    parameters =
      Enum.map(fields, &as_param/1)
      |> format(seperator: ", ")

    builder =
      "export const build_#{snake_case_name} = ({ #{parameters} }: {\n#{all_nullable}\n}): #{name} => {\n" <>
        ("return {\n" |> indent(1)) <>
        (Enum.map(fields, &format_struct/1) |> Enum.map(&js_literal/1) |> format(level: 2)) <>
        "\n" <>
        indent("}\n", 1) <> "}"

    generator =
      if required_fields |> length == 0 do
        "export const new_#{snake_case_name} = () => build_#{snake_case_name}({})"
      else
        build_parameters = Enum.map(required_fields, &as_param/1) |> format(seperator: ", ")
        new_parameters = Enum.map(required_fields, &as_ts(false, &1)) |> format(seperator: ", ")

        "export const new_#{snake_case_name} = (#{new_parameters}) => build_#{snake_case_name}({ #{build_parameters} })"
      end

    render =
      [header, imports, unions, interface, apply, builder, generator]
      |> Enum.filter(&(String.trim(&1) != ""))

    directory = Application.get_env(:genus, :directory, "ts")

    File.mkdir_p!(directory)

    File.write!(
      Path.join(directory, name <> ".ts"),
      Enum.join(render, "\n\n")
    )
  end

  defmacro genus(opts) do
    name = opts[:name]
    imports = Access.get(opts, :imports, [])

    fields =
      opts[:fields]
      |> Enum.map(&get_defaults/1)

    required_fields = Enum.filter(fields, &required?/1)

    build(name, fields, required_fields, imports, __CALLER__)

    keys_and_defaults =
      Enum.map(fields, &format_struct/1)
      |> Enum.map(fn f ->
        case f do
          {field, :required} -> {field, nil}
          _ -> f
        end
      end)

    required =
      Enum.map(required_fields, fn field ->
        case field do
          {[name | _], _} -> name
        end
      end)

    quote bind_quoted: [required: required, keys_and_defaults: keys_and_defaults] do
      @enforce_keys required
      defstruct keys_and_defaults
    end
  end
end
